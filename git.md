# Git

Конечно! Вот шпаргалка по основным командам Git в формате bash-кода с подробными комментариями, описывающими, когда и зачем использовать каждую команду.

### 1. **Инициализация и настройка Git**

```bash
# Инициализация нового локального репозитория в текущей директории.
# Используйте эту команду, если начинаете новый проект или хотите отслеживать изменения в существующем проекте.
git init

# Клонирование удалённого репозитория на локальный компьютер.
# Используйте эту команду, чтобы скачать существующий репозиторий для работы над ним.
git clone https://github.com/username/repository.git

# Настройка имени пользователя для всех ваших коммитов в глобальной конфигурации Git.
# Выполните эту команду один раз на новом компьютере.
git config --global user.name "Your Name"

# Настройка email для всех ваших коммитов в глобальной конфигурации Git.
git config --global user.email "youremail@example.com"
```

### 2. **Основные команды для работы с изменениями**

```bash
# Добавление всех изменений (новые файлы, удаленные файлы, изменения в существующих файлах) в staging area.
# Используйте эту команду перед созданием коммита, чтобы подготовить изменения.
git add .

# Добавление конкретного файла в staging area.
# Используйте эту команду, если хотите добавить только определённый файл в коммит.
git add <file>

# Просмотр статуса репозитория: какие файлы изменены, добавлены или удалены.
# Используйте эту команду, чтобы убедиться, что все нужные изменения добавлены перед коммитом.
git status

# Коммит изменений с сообщением.
# Используйте эту команду, чтобы зафиксировать изменения в истории репозитория.
git commit -m "Your commit message"

# Коммит изменений с подробным описанием. Открывается текстовый редактор для ввода сообщения.
# Используйте, если хотите написать более развёрнутое сообщение о коммите.
git commit

# Изменение последнего коммита (например, если забыли что-то добавить в сообщение).
# Используйте с осторожностью, особенно если вы уже отправили коммит в общий репозиторий.
git commit --amend

# Удаление изменений в рабочем каталоге (возврат к последней версии из коммита).
# Используйте, если хотите отменить локальные изменения до того, как они были добавлены.
git checkout -- <file>
```

### 3. **Работа с ветками**

```bash
# Просмотр списка всех веток.
# Используйте эту команду, чтобы увидеть доступные ветки и текущую активную ветку (отмечена звёздочкой).
git branch

# Создание новой ветки.
# Используйте, чтобы создать новую ветку для работы над новой функцией или фиксацией багов.
git branch <branch-name>

# Переход на существующую ветку.
# Используйте эту команду, чтобы переключиться на другую ветку.
git checkout <branch-name>

# Создание новой ветки и сразу переключение на неё.
# Экономит шаги создания и переключения ветки.
git checkout -b <branch-name>

# Удаление ветки.
# Используйте, если ветка больше не нужна (например, после слияния в основную ветку).
git branch -d <branch-name>

# Принудительное удаление ветки, если ветка не слита в основную.
git branch -D <branch-name>
```

### 4. **Объединение и разрешение конфликтов**

```bash
# Слияние указанной ветки в текущую ветку.
# Используйте эту команду, чтобы объединить работу из другой ветки в текущую.
git merge <branch-name>

# Просмотр файлов, в которых возникли конфликты при слиянии.
# Используйте после слияния, если Git обнаружит конфликтующие изменения.
git status

# Разрешение конфликта в файле вручную, а затем добавление его в staging.
# Используйте эту команду после того, как вы разрешили конфликты в файлах.
git add <file>

# Продолжение слияния после разрешения всех конфликтов.
# Используйте эту команду, чтобы завершить процесс слияния.
git commit
```

### 5. **Удалённые репозитории**

```bash
# Добавление удалённого репозитория.
# Используйте для привязки локального репозитория к удалённому, чтобы можно было его пушить.
git remote add origin https://github.com/username/repository.git

# Просмотр списка удалённых репозиториев.
# Используйте эту команду, чтобы увидеть все удалённые репозитории, к которым привязан локальный репозиторий.
git remote -v

# Отправка изменений в удалённый репозиторий.
# Используйте после коммита, чтобы отправить свои изменения на сервер.
git push origin <branch-name>

# Получение изменений с удалённого репозитория.
# Используйте, чтобы скачать последние изменения и объединить их с вашей текущей веткой.
git pull

# Клонирование удалённого репозитория с указанием другого имени директории.
# Используйте, если хотите склонировать проект в папку с другим именем.
git clone https://github.com/username/repository.git new-folder-name
```

### 6. **Откат изменений**

```bash
# Отмена последнего коммита (оставляет изменения в рабочей директории).
# Используйте, если хотите отменить коммит, но сохранить изменения для дальнейшей правки.
git reset --soft HEAD^

# Полный откат последнего коммита (удаляет изменения).
# Используйте с осторожностью, если хотите полностью удалить коммит и изменения.
git reset --hard HEAD^

# Откат изменений в конкретном файле к состоянию последнего коммита.
# Используйте, если хотите восстановить файл до последней зафиксированной версии.
git checkout HEAD <file>
```

### 7. **История и просмотр изменений**

```bash
# Просмотр истории коммитов с подробной информацией.
# Используйте для просмотра всех коммитов в ветке.
git log

# Просмотр истории в кратком формате (одна строка на каждый коммит).
# Используйте для краткого обзора истории коммитов.
git log --oneline

# Просмотр изменений между текущей версией файла и последним коммитом.
# Используйте для проверки, что было изменено в файлах.
git diff

# Просмотр изменений, которые были добавлены в staging area.
# Используйте для проверки изменений перед коммитом.
git diff --staged

# Просмотр изменений в конкретном коммите.
# Используйте для анализа, какие изменения были внесены в определённом коммите.
git show <commit-hash>
```

### 8. **Работа с тегами**

```bash
# Создание тега для определённого коммита.
# Используйте для пометки важных версий в истории (например, релизов).
git tag <tag-name>

# Просмотр всех тегов.
# Используйте для просмотра списка всех созданных тегов.
git tag

# Отправка тега на удалённый репозиторий.
# Используйте для синхронизации тегов с удалённым репозиторием.
git push origin <tag-name>

# Удаление локального тега.
# Используйте, если тег был создан ошибочно и нужно его удалить.
git tag -d <tag-name>

# Удаление тега из удалённого репозитория.
# Используйте для удаления тега с удалённого сервера.
git push origin --delete <tag-name>
```

### 9. **Реальная работа с Git**

```bash
# Создание новой ветки для новой функциональности и переключение на неё.
git checkout -b feature/new-feature

# Внесение изменений в код и добавление их в staging.
git add .

# Коммит изменений с описанием.
git commit -m "Добавлена новая функциональность"

# Слияние ветки `feature/new-feature` с основной веткой `main`.
git checkout main
git merge feature/new-feature

# Удаление ветки после успешного слияния.
git branch -d feature/new-feature
```


Вот дополнительные примеры команд для работы с Git в связке с удалёнными репозиториями, такими как GitLab, с акцентом на реальные сценарии.

### 1. **Настройка удалённого репозитория**

```bash
# Создание локального репозитория и добавление удалённого репозитория на GitLab.
git init
git remote add origin https://gitlab.com/username/repository.git

# Просмотр информации о подключённом удалённом репозитории.
git remote -v
```

### 2. **Создание новой ветки и отправка на GitLab**

```bash
# Создание новой ветки для работы над функциональностью.
git checkout -b feature/new-feature

# Внесение изменений, добавление их в staged и коммит.
git add .
git commit -m "Добавлена новая функциональность"

# Отправка новой ветки в удалённый репозиторий.
git push -u origin feature/new-feature
```
> **Когда использовать:** При работе с новыми функциями, чтобы сохранять вашу работу в удалённом репозитории и делиться ею с командой.

### 3. **Синхронизация с изменениями на GitLab**

```bash
# Скачивание изменений с удалённого репозитория и слияние их с текущей веткой.
git pull origin main
```
> **Когда использовать:** Перед началом работы, чтобы убедиться, что вы работаете с последней версией кода.

```bash
# Если вы работаете с веткой и хотите подтянуть изменения в другую ветку (например, из main в свою фичу).
git checkout feature/new-feature
git pull origin main
```
> **Когда использовать:** Когда нужно актуализировать вашу ветку с основным кодом из главной ветки.

### 4. **Работа с pull requests (merge requests в GitLab)**

```bash
# Переход на основную ветку (main).
git checkout main

# Слияние изменений из feature/new-feature в основную ветку.
git merge feature/new-feature

# Разрешение конфликтов вручную, если они возникли.
git add <conflict-file>
git commit

# Отправка изменений в удалённый репозиторий (после успешного слияния).
git push origin main
```
> **Когда использовать:** После того как работа над функциональностью завершена и вы хотите слить её в основную ветку.

### 5. **Откат коммитов и работа с историей**

```bash
# Просмотр истории коммитов, чтобы найти нужный коммит.
git log --oneline

# Откат к предыдущему коммиту, оставив изменения в рабочей директории.
git reset --soft HEAD^

# Полный откат изменений и коммита (удаляет все локальные изменения).
git reset --hard HEAD^
```
> **Когда использовать:** Если вы допустили ошибку в последних коммитах и хотите отменить их.

### 6. **Работа с тегами**

```bash
# Создание тега для пометки релиза.
git tag v1.0.0

# Отправка тега на GitLab.
git push origin v1.0.0
```
> **Когда использовать:** Для пометки стабильных версий или релизов проекта.

### 7. **Создание и работа с GitLab CI/CD**

Если вы используете CI/CD в GitLab, важно настроить pipeline через `.gitlab-ci.yml`. Пример минимального pipeline:

```yaml
# .gitlab-ci.yml

stages:
  - build
  - test

build_job:
  stage: build
  script:
    - echo "Building the project"
    - ./build_script.sh

test_job:
  stage: test
  script:
    - echo "Running tests"
    - ./test_script.sh
```

> **Когда использовать:** Чтобы автоматизировать сборку, тестирование и деплой проекта через GitLab CI/CD.

### 8. **Создание форка и отправка изменений в исходный проект**

```bash
# Клонирование форка репозитория на GitLab.
git clone https://gitlab.com/username/forked-repository.git

# Добавление оригинального репозитория как "upstream".
git remote add upstream https://gitlab.com/original-owner/original-repository.git

# Синхронизация вашей ветки с оригинальным проектом.
git fetch upstream
git checkout main
git merge upstream/main

# Отправка изменений в ваш форк.
git push origin main
```
> **Когда использовать:** Если вы вносите изменения в форк проекта и хотите синхронизировать его с оригинальным проектом.

### 9. **Использование GitLab CI/CD переменных**

В GitLab можно использовать переменные в пайплайнах для настройки окружения:

```bash
# Пример команды с использованием переменной окружения (например, токен для деплоя).
echo $CI_JOB_TOKEN
```
> **Когда использовать:** Для доступа к секретам и конфиденциальным данным в процессе сборки и деплоя.

### 10. **Работа с submodules**

```bash
# Инициализация и добавление git-субмодуля.
git submodule add https://gitlab.com/username/submodule-repo.git

# Инициализация всех субмодулей после клонирования проекта.
git submodule init
git submodule update
```
> **Когда использовать:** Если ваш проект зависит от других репозиториев, которые вы хотите встроить как модули.

Эти примеры помогут вам эффективно работать с Git в связке с GitLab, решая повседневные задачи: от создания веток до автоматизации CI/CD.



Эта шпаргалка покрывает основные команды Git, которые используются в повседневной разработке. Она поможет вам эффективно работать с Git как в одиночку, так и в команде.









*   [Общее](https://github.com/nicothin/web-development/tree/master/git#Общее)
*   [Консольные команды](https://github.com/nicothin/web-development/tree/master/git#Консольные-команды)
*   [Примеры реальной работы](https://github.com/nicothin/web-development/tree/master/git#Примеры)



## Общее

Git — система контроля версий (файлов). Что-то вроде возможности сохраняться в компьютерных играх (в Git эквивалент игрового сохранения — коммит). **Важно**: добавление файлов к «сохранению» двухступенчатое: сначала добавляем файл в индекс (`git add`), потом «сохраняем» (`git commit`).

Любой файл в директории существующего репозитория может находиться или не находиться под версионным контролем (отслеживаемые и неотслеживаемые).

Отслеживаемые файлы могут быть в 3-х состояниях: неизменённые, изменённые, проиндексированные (готовые к коммиту).

### Ключ к пониманию

Ключ к пониманию концепции git — знание о «трех деревьях»:

- Рабочая директория — файловая система проекта (те файлы, с которыми вы работаете).
- Индекс — список отслеживаемых git-ом файлов и директорий, промежуточное хранилище изменений (редактирование, удаление отслеживаемых файлов).
- Директория `.git/` — все данные контроля версий этого проекта (вся история разработки: коммиты, ветки, теги и пр.).

Коммит — «сохранение» (хранит набор изменений, сделанный в рабочей директории с момента предыдущего коммита). Коммит неизменен, его нельзя отредактировать.

У всех коммитов (кроме самого первого) есть один или более родительских коммитов, поскольку коммиты хранят изменения от предыдущих состояний.

### Простейший цикл работ

- Редактирование, добавление, удаление файлов (собственно, работа).
- Индексация/добавление файлов в индекс (указание для git какие изменения нужно будет закоммитить).
- Коммит (фиксация изменений).
- Возврат к шагу 1 или отход ко сну.

### Указатели

- `HEAD` — указатель на текущий коммит или на текущую ветку (то есть, в любом случае, на коммит). Указывает на родителя коммита, который будет создан следующим.
- `ORIG_HEAD` — указатель на коммит, с которого вы только что переместили `HEAD` (командой `git reset ...`, например).
- Ветка (`master`, `develop` etc.) — указатель на коммит. При добавлении коммита, указатель ветки перемещается с родительского коммита на новый.
- Теги — простые указатели на коммиты. Не перемещаются.



### Настройки

Перед началом работы нужно выполнить некоторые настройки:

```
git config --global user.name "Your Name" # указать имя, которым будут подписаны коммиты
git config --global user.email "e@w.com"  # указать электропочту, которая будет в описании коммитера
```

Если вы в Windows:

```
git config --global core.autocrlf true # включить преобразование окончаний строк из CRLF в LF
```


### Указание неотслеживаемых файлов

Файлы и директории, которые не нужно включать в репозиторий, указываются в файле `.gitignore`. Обычно это устанавливаемые зависимости (`node_modules/`, `bower_components/`), готовая сборка `build/` или `dist/` и подобные, создаваемые при установке или запуске. Каждый файл или директория указываются с новой строки, [возможно использование шаблонов](http://git-scm.com/book/ru/v2/%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B-Git-%D0%97%D0%B0%D0%BF%D0%B8%D1%81%D1%8C-%D0%B8%D0%B7%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B9-%D0%B2-%D1%80%D0%B5%D0%BF%D0%BE%D0%B7%D0%B8%D1%82%D0%BE%D1%80%D0%B8%D0%B9#Игнорирование-файлов).


### Консоль

[Как использовать консоль в Windows](http://nicothin.pro/page/console-windows) (на OSX и Linux сразу есть хорошая консоль (терминал)). [Как комфортно работать с GitHub в консоли Windows](http://nicothin.pro/page/kak-komfortno-rabotat-s-github-v-konsoli-windows).


### Длинный вывод в консоли: Vim

Вызов некоторых консольных команд приводит к необходимости очень длинного вывода в консоль (пример: вывод истории всех изменений в файле командой `git log -p fileName.txt`). При этом прямо в консоли запускается редактор [Vim](https://ru.wikipedia.org/wiki/Vim). Он работает в нескольких режимах, из которых Вас заинтересуют режим вставки (редактирование текста) и нормальный (командный) режим. Чтобы попасть из Vim обратно в консоль, нужно в командном режиме ввести <kbd>:q</kbd>. Переход в командный режим из любого другого: <kbd>Esc</kbd>.

Если нужно что-то написать, нажмите <kbd>i</kbd> — это переход в режим вставки текста. Если нужно сохранить изменения, перейдите в командный режим и наберите <kbd>:w</kbd>.

[Чуть-чуть больше команд](vim.md).





## Консольные команды

### Создать новый репозиторий

``` bash
git init             # создать новый проект в текущей директории
git init folder-name # создать новый проект в указанной директории
```


### Клонирование репозитория

``` bash
git clone https://github.com:nicothin/web-design.git            # клонировать удаленный репозиторий в одноименную директорию
git clone https://github.com:nicothin/web-design.git FolderName # клонировать удаленный репозиторий в директорию «FolderName»
git clone https://github.com:nicothin/web-design.git .          # клонировать репозиторий в текущую директорию
```


### Просмотр изменений

``` bash
git status              # показать состояние репозитория (отслеживаемые, изменённые, новые файлы и пр.)
git diff                # сравнить рабочую директорию и индекс (неотслеживаемые файлы ИГНОРИРУЮТСЯ)
git diff --color-words  # сравнить рабочую директорию и индекс, показать отличия в словах (неотслеживаемые файлы ИГНОРИРУЮТСЯ)
git diff index.html     # сравнить файл из рабочей директории и индекс
git diff HEAD           # сравнить рабочую директорию и коммит, на который указывает HEAD (неотслеживаемые файлы ИГНОРИРУЮТСЯ)
git diff --staged       # сравнить индекс и коммит с HEAD
git diff master feature # посмотреть что сделано в ветке feature по сравнению с веткой master
git diff --name-only master feature # посмотреть что сделано в ветке feature по сравнению с веткой master, показать только имена файлов
git diff master...feature # посмотреть что сделано в ветке feature с момента (коммита) расхождения с master
```


### Добавление изменений в индекс

``` bash
git add .        # добавить в индекс все новые, изменённые, удалённые файлы из текущей директории и её поддиректорий
git add text.txt # добавить в индекс указанный файл (был изменён, был удалён или это новый файл)
git add -i       # запустить интерактивную оболочку для добавления в индекс только выбранных файлов
git add -p       # показать новые/изменённые файлы по очереди с указанием их изменений и вопросом об отслеживании/индексировании
```


### Удаление изменений из индекса

``` bash
git reset            # убрать из индекса все добавленные в него изменения (в рабочей директории все изменения сохранятся), антипод git add
git reset readme.txt # убрать из индекса изменения указанного файла (в рабочей директории изменения сохранятся)
```


### Отмена изменений

``` bash
git checkout text.txt      # ОПАСНО: отменить изменения в файле, вернуть состояние файла, имеющееся в индексе
git reset --hard           # ОПАСНО: отменить изменения; вернуть то, что в коммите, на который указывает HEAD (незакомиченные изменения удалены из индекса и из рабочей директории, неотслеживаемые файлы останутся на месте)
git clean -df              # удалить неотслеживаемые файлы и директории
```


### Коммиты

``` bash
git commit -m "Name of commit"    # зафиксировать в коммите проиндексированные изменения (закоммитить), добавить сообщение
git commit -a -m "Name of commit" # проиндексировать отслеживаемые файлы (ТОЛЬКО отслеживаемые, но НЕ новые файлы) и закоммитить, добавить сообщение
```


### Отмена коммитов и перемещение по истории

Все коммиты, которые уже были отправлены в удалённый репозиторий, должны отменяться новыми коммитами (`git revert`), дабы избежать проблем с историей разработки у других участников проекта.

``` bash
git revert HEAD --no-edit    # создать новый коммит, отменяющий изменения последнего коммита без запуска редактора сообщения
git revert b9533bb --no-edit # то же, но отменяются изменения, внесённые коммитом с указанным хешем (b9533bb)
```

**Все команды, приведённые ниже можно выполнять ТОЛЬКО если коммиты еще не были отправлены в удалённый репозиторий.**

``` bash
# ВНИМАНИЕ! Опасные команды, можно потерять незакоммиченные изменения
git commit --amend -m "Название"  # «перекоммитить» изменения последнего коммита, заменить его новым коммитом с другим сообщением (сдвинуть текущую ветку на один коммит назад, сохранив рабочую директорию и индекс «как есть», создать новый коммит с данными из «отменяемого» коммита, но новым сообщением)
git reset --hard @~      # передвинуть HEAD (и ветку) на предыдущий коммит, рабочую директорию и индекс сделать такими, какими они были в момент предыдущего коммита
git reset --hard 75e2d51 # передвинуть HEAD (и ветку) на коммит с указанным хешем, рабочую директорию и индекс сделать такими, какими они были в момент указанного коммита
git reset --soft @~      # передвинуть HEAD (и ветку) на предыдущий коммит, но в рабочей директории и индексе оставить все изменения
git reset --soft @~2     # то же, но передвинуть HEAD (и ветку) на 2 коммита назад
git reset @~             # передвинуть HEAD (и ветку) на предыдущий коммит, рабочую директорию оставить как есть, индекс сделать таким, каким он был в момент предыдущего коммита (удобнее, чем git reset --soft @~, если индекс нужно задать заново)
# Почти как git reset --hard, но безопаснее: не получится потерять изменения в рабочей директории
git reset --keep @~      # передвинуть HEAD (и ветку) на предыдущий коммит, сбросить индекс, но в рабочей директории оставить изменения, если возможно (если файл с изменениями между коммитами менялся, будет выдана ошибка и переключение не произойдёт)
```


### Временно переключиться на другой коммит

``` bash
git checkout b9533bb # переключиться на коммит с указанным хешем (переместить HEAD на указанный коммит, рабочую директорию вернуть к состоянию, на момент этого коммита)
git checkout master  # переключиться на коммит, на который указывает master (переместить HEAD на коммит, на который указывает master, рабочую директорию вернуть к состоянию на момент этого коммита)
```


### Переключиться на другой коммит и продолжить работу с него

Потребуется создание новой ветки, начинающейся с указанного коммита.

``` bash
git checkout -b new-branch 5589877   # создать ветку new-branch, начинающуюся с коммита c хешем 5589877 (переместить HEAD на указанный коммит, рабочую директорию вернуть к состоянию, на момент этого коммита, создать указатель на этот коммит (ветку) с указанным именем)
```


### Восстановление изменений

``` bash
git checkout 5589877 index.html  # восстановить в рабочей директории указанный файл на момент указанного коммита (и добавить это изменение в индекс) (git reset index.html для удаления из индекса, но сохранения изменений в файле)
```


### Копирование коммита (перенос коммитов)

``` bash
git cherry-pick 5589877          # скопировать на активную ветку изменения из указанного коммита, закоммитить эти изменения
git cherry-pick master~2..master # скопировать на активную ветку изменения из master (2 последних коммита)
git cherry-pick -n 5589877       # скопировать на активную ветку изменения из указанного коммита, но НЕ КОММИТИТЬ (подразумевается, что мы сами потом закоммитим)
git cherry-pick master..feature  # скопировать на активную ветку изменения из всех коммитов ветки feature с момента её расхождения с master (похоже на слияние веток, но это копирование изменений, а не слияние), закоммитить эти изменения; это может вызвать конфликт
git cherry-pick --abort    # прервать конфликтный перенос коммитов
git cherry-pick --continue # продолжить конфликтный перенос коммитов (сработает только после решения конфликта)
```


### Удаление файла

``` bash
git rm text.txt    # удалить отслеживаемый неизменённый файл и проиндексировать это изменение
git rm -f text.txt # удалить отслеживаемый изменённый файл и проиндексировать это изменение
git rm -r log/     # удалить всё содержимое отслеживаемой директории log/ и проиндексировать это изменение
git rm ind*        # удалить все отслеживаемые файлы с именем, начинающимся на «ind» в текущей директории и проиндексировать это изменение
git rm --cached readme.txt # удалить из отслеживаемых индексированный файл (ФАЙЛ ОСТАНЕТСЯ НА МЕСТЕ) (часто используется для нечаянно добавленных в отслеживаемые файлов)
```


### Перемещение/переименование файлов

Для git не существует переименования. Переименование воспринимается как удаление старого файла и создание нового. Факт переименования может быть определен только после индексации изменения.

``` bash
git mv text.txt test_new.txt # переименовать файл «text.txt» в «test_new.txt» и проиндексировать это изменение
git mv readme_new.md folder/ # переместить файл readme_new.md в директорию folder/ (должна существовать) и проиндексировать это изменение
```


### История коммитов

Выход из длинного лога вывода: `q`.

``` bash
git log master             # показать коммиты в указанной ветке
git log -2                 # показать последние 2 коммита в активной ветке
git log -2 --stat          # показать последние 2 коммита и статистику внесенных ими изменений
git log -p -22             # показать последние 22 коммита и внесенную ими разницу на уровне строк
git log --graph -10        # показать последние 10 коммитов с ASCII-представлением ветвления
git log --since=2.weeks    # показать коммиты за последние 2 недели
git log --after '2018-06-30' # показать коммиты, сделанные после указанной даты
git log index.html         # показать историю изменений файла index.html (только коммиты)
git log -5 index.html      # показать историю изменений файла index.html, последние 5 коммитов (только коммиты)
git log -p index.html      # показать историю изменений файла index.html (коммиты и изменения)
git log -G'myFunction' -p  # показать все коммиты, в которых менялись строки с myFunction (в кавычках регулярное выражение)
git log -L '/<head>/','/<\/head>/':index.html # показать изменения от указанного до указанного регулярных выражений в указанном файле
git log --grep fix         # показать коммиты, в описании которых есть буквосочетание fix (регистрозависимо, только коммиты текущей ветки)
git log --grep fix -i      # показать коммиты, в описании которых есть буквосочетание fix (регистроНЕзависимо, только коммиты текущей ветки)
git log --grep 'fix(ing|me)' -P # показать коммиты, в описании которых есть совпадения для регулярного выражения (только коммиты текущей ветки)
git log --pretty=format:"%h - %an, %ar : %s" -4 # показать последние 4 коммита с форматированием выводимых данных
git log --pretty=format:"%h %ad | %s%d [%an]" --graph --date=short # мой формат вывода, висящий на алиасе оболочки
git log master..branch_99  # показать коммиты из ветки branch_99, которые не влиты в master
git log branch_99..master  # показать коммиты из ветки master, которые не влиты в branch_99
git log master...branch_99 --boundary -- graph # показать коммиты из указанных веток, начиная с их расхождения (коммит расхождения будет показан)
```

``` bash
git show 60d6582           # показать изменения из коммита с указанным хешем
git show HEAD~             # показать данные о предыдущем коммите в активной ветке
git show @~                # аналогично предыдущему
git show HEAD~3            # показать данные о коммите, который был 3 коммита назад
git show my_branch~2       # показать данные о коммите, который был 2 коммита назад в указанной ветке
git show @~:index.html     # показать контент указанного файла на момент предыдущего (от HEAD) коммита
git show :/"подвал"        # показать самый новый коммит, в описании которого есть указанное слово (из любой ветки)
```


### Кто написал строку

``` bash
git blame README.md --date=short -L 5,8 # показать строки 5-8 указанного файла и коммиты, в которых строки были добавлены
```


### История изменений указателей (веток, HEAD)

```
git reflog -20             # показать последние 20 изменений положения указателя HEAD
git reflog --format='%C(auto)%h %<|(20)%gd %C(blue)%cr%C(reset) %gs (%s)' -20 # то же, но с указанием давности действий
```


### Ветки

``` bash
git branch                 # показать список веток
git branch -v              # показать список веток и последний коммит в каждой
git branch new_branch      # создать новую ветку с указанным именем на текущем коммите
git branch new_branch 5589877 # создать новую ветку с указанным именем на указанном коммите
git branch -f master 5589877  # переместить ветку master на указанный коммит
git branch -f master master~2 # переместить ветку master на 2 коммита назад
git checkout new_branch    # перейти в указанную ветку
git checkout -b new_branch # создать новую ветку с указанным именем и перейти в неё
git checkout -B master 5589877 # переместить ветку с указанным именем на указанный коммит и перейти в неё
git merge hotfix           # влить в ветку, в которой находимся, данные из ветки hotfix
git merge hotfix -m "Горячая правка" # влить в ветку, в которой находимся, данные из ветки hotfix (указано сообщение коммита слияния)
git merge hotfix --log     # влить в ветку, в которой находимся, данные из ветки hotfix, показать редактор описания коммита, добавить в него сообщения вливаемых коммитов
git merge hotfix --no-ff   # влить в ветку, в которой находимся, данные из ветки hotfix, запретить простой сдвиг указателя, изменения из hotfix «останутся» в ней, а в активной ветке появится только коммит слияния
git branch -d hotfix       # удалить ветку hotfix (используется, если её изменения уже влиты в главную ветку)
git branch --merged        # показать ветки, уже слитые с активной
git branch --no-merged     # показать ветки, не слитые с активной
git branch -a              # показать все имеющиеся ветки (в т.ч. на удаленных репозиториях)
git branch -m old_branch_name new_branch_name # переименовать локально ветку old_branch_name в new_branch_name
git branch -m new_branch_name # переименовать локально ТЕКУЩУЮ ветку в new_branch_name
git push origin :old_branch_name new_branch_name # применить переименование в удаленном репозитории
git branch --unset-upstream # завершить процесс переименования
```


### Теги

``` bash
git tag v1.0.0               # создать тег с указанным именем на коммите, на который указывает HEAD
git tag -a -m 'В продакшен!' v1.0.1 master # создать тег с описанием на том коммите, на который смотрит ветка master
git tag -d v1.0.0            # удалить тег с указанным именем(ами)
git tag -n                   # показать все теги, и по 1 строке сообщения коммитов, на которые они указывают
git tag -n -l 'v1.*'         # показать все теги, которые начинаются с 'v1.*'
```


### Временное сохранение изменений без коммита

``` bash
git stash     # временно сохранить незакоммиченные изменения и убрать их из рабочей директории
git stash pop # вернуть сохраненные командой git stash изменения в рабочую директорию
```


### Удалённые репозитории

Есть два распространённых способа привязать удалённый репозиторий к локальному: по HTTPS и по SSH. Если SSH у вас не настроен (или вы не знаете что это), привязывайте удалённый репозиторий по HTTPS (адрес привязываемого репозитория должен начинаться с https://).

``` bash
git remote -v              # показать список удалённых репозиториев, связанных с локальным
git remote remove origin   # убрать привязку удалённого репозитория с сокр. именем origin
git remote add origin https://github.com:nicothin/test.git # добавить удалённый репозиторий (с сокр. именем origin) с указанным URL
git remote rm origin       # удалить привязку удалённого репозитория
git remote show origin     # получить данные об удалённом репозитории с сокращенным именем origin
git fetch origin           # скачать все ветки с удаленного репозитория (с сокр. именем origin), но не сливать со своими ветками
git fetch origin master    # то же, но скачивается только указанная ветка
git checkout --track origin/github_branch # создать локальную ветку github_branch (данные взять из удалённого репозитория с сокр. именем origin, ветка github_branch) и переключиться на неё
git push origin master     # отправить в удалённый репозиторий (с сокр. именем origin) данные своей ветки master
git pull origin            # влить изменения с удалённого репозитория (все ветки)
git pull origin master     # влить изменения с удалённого репозитория (только указанная ветка)
```


### Конфликт слияния

Предполагается ситуация: есть ветка `master` и есть ветка `feature`. В обеих ветках есть коммиты, сделанные после расхождения веток. В ветку `master` пытаемся влить ветку `feature` (`git merge feature`), получаем конфликт, т.к. в обеих ветках есть изменения одной и той же строки в файле `index.html`.

При возникновении конфликта, репозиторий находится в состоянии прерванного слияния. Нужно оставить в конфликтующих местах файлов только нужный код, проиндексировать изменения и закоммитить.

``` bash
git merge feature                # влить в активную ветку изменения из ветки feature
git merge-base master feature    # показать хеш последнего общего коммита для двух указанных веток
git checkout --ours index.html   # оставить в конфликтном файле (index.html) состояние ветки, В КОТОРУЮ мы вливаем (в примере — из ветки master)
git checkout --theirs index.html # оставить в конфликтном файле (index.html) состояние ветки, ИЗ КОТОРОЙ мы вливаем (в примере — из ветки feature)
git checkout --merge index.html  # показать в конфликтном файле (index.html) сравнение содержимого сливаемых веток (для ручного редактирования)
git checkout --conflict=diff3  --merge index.html # показать в конфликтном файле (index.html) сравнение содержимого сливаемых веток плюс то, что было в месте конфликта в коммите, на котором разошлись сливаемые ветки
```

``` bash
git reset --hard  # прекратить это прерванное слияние, вернуть рабочую директорию и индекс как было в момент коммита, на который указывает HEAD, а я пойду немного поплачу
git reset --merge # прекратить это прерванное слияние, но оставить изменения, не закоммиченные до слияния (для случая, когда слияние делается не на чистом статусе)
git reset --abort # то же, что и строкой выше
```


### «Перенос» ветки

Можно «переместить» ответвление какой-либо ветки от основной на произвольный коммит. Это нужно для того, чтобы в «переносимой» ветке появились какие-либо изменения, внесённые в основной ветке (уже после ответвления переносимой).

Нельзя «переносить» ветку, если она уже отправлена на удалённый репозиторий.

``` bash
git rebase master # перенести все коммиты (создать их копии) активной ветки так, будто активная ветка ответвилась от master на нынешней вершине master (часто вызывает конфликты)
git rebase --onto master feature # перенести коммиты активной ветки на master, начиная с того места, в котором активная ветка отделилась от ветки feature
git rebase --abort # прервать конфликтный rebase, вернуть рабочую директорию и индекс к состоянию до начала rebase
git rebase --continue # продолжить конфликтный rebase (сработает только после разрешения конфликта и индексации такого разрешения)
```

#### Как отменить rebase

``` bash
git reflog feature -2        # смотрим лог перемещений ветки, которой делали rebase (в этом примере — feature), видим последний коммит ПЕРЕД rebase, на него и нужно перенести указатель ветки
git reset --hard feature@{1} # переместить указатель ветки feature на один коммит назад, обновить рабочую директорию и индекс
```


### Разное

``` bash
git archive -o ./project.zip HEAD # создать архив с файловой структурой проекта по указанному пути (состояние репозитория, соответствующее указателю HEAD)
```





## Примеры

Собираем коллекцию простых и сложных примеров работы.


### Начало работы

Создание нового репозитория, первый коммит, привязка удалённого репозитория с github.com, отправка изменений в удалённый репозиторий.

``` bash
# указана последовательность действий:
# создана директория проекта, мы в ней
git init                      # создаём репозиторий в этой директории
touch readme.md               # создаем файл readme.md
git add readme.md             # добавляем файл в индекс
git commit -m "Старт"         # создаем коммит
git remote add origin https://github.com:nicothin/test.git # добавляем предварительно созданный пустой удаленный репозиторий
git push -u origin master     # отправляем данные из локального репозитория в удаленный (в ветку master)
```


### «Внесение изменений» в коммит

Только если коммит ещё не был отправлен в удалённый репозиторий.

``` bash
# указана последовательность действий:
subl inc/header.html          # редактируем и сохраняем разметку «шапки»
git add inc/header.html       # индексируем измененный файл
git commit -m "Убрал телефон из шапки" # делаем коммит
# ВНИМАНИЕ: коммит пока не был отправлен в удалённый репозиторий
# сознаём, что нужно было еще что-то сделать в этом коммите.
subl inc/header.html          # вносим изменения
git add inc/header.html       # индексируем измененный файл (можно git add .)
git commit --amend -m "«Шапка»: выполнена задача №34" # заново делаем коммит
```


### Работа с ветками

Есть master (публичная версия сайта), выполняем масштабную задачу (переверстать «шапку»), но по ходу работ возникает необходимость подправить критичный баг (неправильно указан контакт в «подвале»).

``` bash
# указана последовательность действий:
git checkout -b new-page-header # создадим новую ветку для задачи изменения «шапки» и перейдём в неё
subl inc/header.html            # редактируем разметку «шапки»
git commit -a -m "Новая шапка: смена логотипа" # делаем коммит (работа еще не завершена)
# тут выясняется, что есть баг с контактом в «подвале»
git checkout master             # возвращаемся к ветке master
subl inc/footer.html            # устраняем баг и сохраняем разметку «подвала»
git commit -a -m "Исправление контакта в подвале" # делаем коммит
git push                        # отправляем коммит с быстрым критическим изменением в master в удалённом репозитории
git checkout new-page-header    # переключаемся обратно в ветку new-page-header для продолжения работ над «шапкой»
subl inc/header.html            # редактируем и сохраняем разметку «шапки»
git commit -a -m "Новая шапка: смена навигации" # делаем коммит (работа над «шапкой» завершена)
git checkout master             # переключаемся в ветку master
git merge new-page-header       # вливаем в master изменения из ветки new-page-header
git branch -d new-page-header   # удаляем ветку new_page_header
```


### Работа с ветками, слияние и откат к состоянию до слияния

Была ветка `fix`, в которой исправляли баг. Исправили, влили `fix` в `master`. но тут выяснилось, что это исправление ломает какую-то функциональность, Нужно откатить `master` к состоянию без слияния (наличие бага менее критично, чем порча функциональности).

``` bash
# находимся в ветке fix, баг уже «исправлен»
git checkout master            # переключаемся на master
git merge fix                  # вливаем изменения из fix в master
# видим проблему: часть функциональности сломалась
git checkout fix               # переключаемся на fix (пока мы в master, git не даст ее двигать)
git branch -f master ORIG_HEAD # передвигаем ветку master на коммит, указанный в ORIG_HEAD (тот, на который указывала master до вливания fix)
```



### Работа с ветками, конфликт слияния

Есть ветка `master` (публичная версия сайта), в двух параллельных ветках (`branch-1` и `branch-2`) было отредактировано одно и то же место одного и того же файла, первую ветку (`branch-1`) влили в master, попытка влить вторую вызывает конфликт.

``` bash
# указана последовательность действий:
git checkout master           # переключаемся на ветку master
git checkout -b branch-1      # создаём ветку branch-1, основанную на ветке master
subl .                        # редактируем и сохраняем файлы
git commit -a -m "Правка 1"   # коммитим
git checkout master           # возвращаемся к ветке master
git checkout -b branch-2      # создаём ветку branch-2, основанную на ветке master
subl .                        # редактируем и сохраняем файлы
git commit -a -m "Правка 2"   # коммитим
git checkout master           # возвращаемся к ветке master
git merge branch-1            # вливаем изменения из ветки branch-1 в текущую ветку (master), удача (автослияние)
git merge branch-2            # вливаем изменения из ветки branch-2 в текущую ветку (master), КОНФЛИКТ автослияния
# Automatic merge failed; fix conflicts and then commit the result.
subl .                        # выбираем в конфликтных файлах те участки, которые нужно оставить, сохраняем
git commit -a -m "Устранение конфликта" # коммитим результат устранения конфликта
```



### Синхронизация репозитория-форка с мастер-репозиторием

Есть некий репозиторий на github.com, от него нами был сделан форк, добавлены какие-то изменения. Оригинальный (мастер-)репозиторий был как-то обновлён. Задача: стянуть с мастер-репозитория изменения (которые там внесены уже после того, как мы его форкнули).

``` bash
# указана последовательность действий:
git remote add upstream https://github.com:address.git # добавляем удаленный репозиторий: сокр. имя — upstream, URL мастер-репозитория
git fetch upstream            # стягиваем все ветки мастер-репозитория, но пока не сливаем со своими
git checkout master           # переключаемся на ветку master своего репозитория
git merge upstream/master     # вливаем стянутую ветку master удалённого репозитория upstream в свою ветку master
```



### Ошибка в работе: закоммитили в мастер, но поняли, что нужно было коммитить в новую ветку

**ВАЖНО: это сработает только если коммит еще не отправлен в удалённый репозиторий.**

``` bash
# указана последовательность действий:
# сделали изменения, проиндексировали их, закоммитили в master, но ЕЩЁ НЕ ОТПРАВИЛИ (не делали git push)
git checkout -b new-branch    # создаём новую ветку из master
git checkout master           # переключаемся на master
git reset HEAD~ --hard        # сдвигаем указатель (ветку) master на 1 коммит назад
git checkout new-branch       # переключаемся обратно на новую ветку для продолжения работы
```



### Нужно вернуть содержимое файла к состоянию, бывшему в каком-либо коммите (известен хеш коммита)

``` bash
# указана последовательность действий:
git checkout f26ed88 -- index.html # восстановить в рабочей директории состояние указанного файла на момент указанного коммита, добавить это изменение в индекс
git commit -am "Navigation fixs"   # сделать коммит
```



### При любом действии с github (или другим удалённым сервисом) запрашивается логин и пароль

Речь именно о запросе пары логин + пароль, а не ключевой фразы. Происходит это потому, что git по умолчанию не сохранит пароль для доступа к репозиторию по HTTPS.

Простое решение: [указать git кешировать ваш пароль](https://help.github.com/articles/caching-your-github-password-in-git/).



## `.gitattributes`

```
* text=auto

*.html diff=html
*.css  diff=css
*.scss diff=css
```

# МОИ ВАРИАНТЫ


# GIT


https://habr.com/ru/companies/ruvds/articles/599929/
https://proglib.io/p/git-for-half-an-hour
https://contentim.ru/post/git

Коммиты
git commit -m "Name of commit"    # зафиксировать в коммите проиндексированные изменения (закоммитить), добавить сообщение


.gitignore тоже добавляется в индекс
Добавляются к примеру:
*.log
/storage
/config/database.php
/config/app.php
.htaccess
/node_modules
/themes/sambiahotel/content

git rm —cached filename удалить из отслеживания после добавления в .gitignore
	—cached без удаления из файловой системы


Ветки
git status показывает файлы находящиеся в индексе,  на какой ветке в данный момент находимся и последние коммиты
git log история коммитов
git checkout –b dev1 создать ветку с именем dev1, одновременно переключившись на нее
git branch  посмотреть список доступных веток. Зеленый цвет обозначает что это локальная ветка
git branch -a посмотреть список доступных веток, включая в удаленных репозиториях, помечены красным
git branch new-branch-name создать новую ветку

удаленные репозитории
git remote -v список удаленных репозиториев

git push origin master     # отправить в удалённый репозиторий (с сокр. именем origin) данные своей ветки master

когда на локальном есть ветка а на удаленном нет соответствующей
git push –u origin dev1 отправляем именно ветку dev1 в удаленный репозиторий origin 
git push –u origin main отплавяем ветку main в удаленный репозиторий origin
	origin указатель на удаленный репозиторий
	-u отправить в ветку с таким же названием как локальная и создать связь между этими ветками, в ином случае выдаст ошибку если на удаленном нет ветки с соответствующим именем. После этого можно просто использовать находясь на данной ветке, просто git push


git pull origin main  получить изменения с удаленного репозитория origin и его ветки main

# указана последовательность действий:
# создана директория проекта, мы в ней
git init                      # создаём репозиторий в этой директории
touch readme.md               # создаем файл readme.md
git add readme.md             # добавляем файл в индекс
git commit -m "Старт"         # создаем коммит
git remote add origin https://github.com:nicothin/test.git # добавляем предварительно созданный пустой удаленный репозиторий

git push -u origin main     # отправляем данные из локального репозитория в удаленный (в ветку main)

Слияние веток
git merge new-branch вливаем ветку new-branch  в текущую ветку, в которой находимся

Откладывание изменений
 
git stash  отложить пак изменений
git stash list просмотреть список отложенных паков изменений
git stash pop вернуть последний пак изменений

Отмена изменений
Не или из стейджа
git diff filename просмотреть сделанные изменения. Между файлом и стейджом
git diff просмотреть изменения всех файлов. Между файлом и стейджом

git restore filename безвозвратное удаление незакомиченных изменений в конкретном файле
git restore –staged безвозвратное удаление не закомиченных изменений в конкретном файле из стейджа
git reset --hard безвозвратно удаляет все незакомиченные изменения во всех файлах, даже если они не были добавлены в стейдж 
git clean -f удаляет все новые неотслеживаемые незакомиченные изменения
git rm --cached

Отмена закомиченных изменений
git checkout commit_hash filename возвращает файл в состояние на указанный коммит и сразу добавляется в стейдж…. т.е  восстановить в рабочей директории указанный файл на момент указанного коммита (и добавить это изменение в индекс) (git reset index.html для удаления из индекса, но сохранения изменений в файле. git restore –staged для удаления изменений  и удаление из индекса )
git revert commit_name отменяет указанный коммит, при этом все последующие коммиты остаются без изменений
git revert --no-commit commit_name  можно отменить несколько коммитов подряд, не делая каждый раз коммит и сделав единый коммит  в конце

Сброс коммитов
git reset --soft commit_name  если указываем предпоследний коммит, то мы сбросим изменения последнего коммита и отправим их в индекс
git reset –mixed то же что и мягкий режим, но не добавляем в индекc Можно просто писать git reset без этого параметра, т.к. он по умолчанию идет
git reset HEAD~1 сбрасывает один последний коммит. Если другая цифра, то соотвественно
 git reset –hard удаляет все изменения и коммиты позднее указанного коммита
 git commit --amend -m редактирование комментария последнего коммита
git commit --amend --no-edit редактирование файлов последнего коммита

git mv filename1 filename2 переименование файла


## GIT ПРАКТИКА

Заливка своего проекта на гитхаб
	Создаем проект на гитхабе
	ssh-keygen На локальной машине генерируем ssh ключи находясь в домашней директории, везде enter
	cat id_rsa.pub Выводим публичный ключ и копируем его в настройки гитхаба в ssh ключи

	на локальной машине создаем репозиторий
	git init								инициализируем локальный репозиторий
	git add . 								добавляем все в индекс
	git commit -m "first commit"			делаем коммит
	git branch -M main						создаем ветку main
	git remote add origin git@github.com:alexxxneo/alex-info.git
	git push --set-upstream origin main 	сопоставляем локальную мастер ветку main с веткой мастер веткой main в удаленном репозитории
	git push -u origin main					отправляем данные в удаленный репозиторий

